# Nix Flakes Tutorial

This tutorial will explain what Nix Flakes are, why we are using them, and what the recent commands were for.

## 1. What are Nix Flakes?

Nix Flakes are a new feature in Nix that improves reproducibility and composability. Think of them as a way to package up your Nix expressions (your `.nix` files) in a standardized way, making them easy to share and reuse.

**Key benefits of flakes:**

*   **Pinned Dependencies:** Flakes lock the exact versions of all their dependencies (like `nixpkgs`). This means that your build will be the same, every time, regardless of when or where you run it.
*   **Self-Contained:** Flakes are self-contained units. They don't depend on any external channels or the state of your system.
*   **Clear Inputs and Outputs:** Flakes have a clear separation of inputs (dependencies) and outputs (the things they provide, like packages or configurations).

## 2. The `flake.nix` file

The `flake.nix` file is the heart of a flake. It defines everything about your flake.

It has two main sections:

*   `inputs`: This section declares the dependencies of your flake. In our case, the inputs are `nixpkgs` (the Nix package repository) and `nix-on-droid`.
*   `outputs`: This section defines what your flake provides. In our case, it provides a `nixOnDroidConfigurations.default`, which is your system configuration.

Here is our `flake.nix` file:

```nix
{
  description = "Basic example of Nix-on-Droid system config.";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/master";

    nix-on-droid = {
      url = "github:nix-community/nix-on-droid/master";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, nix-on-droid }: {

    nixOnDroidConfigurations.default = nix-on-droid.lib.nixOnDroidConfiguration {
      pkgs = import nixpkgs { system = "aarch64-linux"; };
      modules = [ ./nix-on-droid.nix ];
    };

  };
}
```

## 3. The `flake.lock` file

The `flake.lock` file is automatically generated by Nix when you first use a flake. It records the exact commit hash and content hash of all the inputs defined in your `flake.nix` file.

This file is what guarantees that your builds are reproducible. When you run a command that uses the flake, Nix will use the exact versions of the inputs specified in the `flake.lock` file.

You should commit this file to your version control system (like `git`).

## 4. The `nix flake update` command

The `nix flake update` command is used to update the `flake.lock` file. It will fetch the latest versions of all the inputs from their respective sources (e.g., GitHub) and update the `flake.lock` file with the new commit hashes.

You should run this command when you want to update your dependencies to their latest versions.

## 5. The current problem: `gemini-cli` not found

The original problem was that the `nix-on-droid switch` command failed with an error `undefined variable 'gemini-cli'`. This happened because the version of `nixpkgs` we were using (`nixos-24.05`) did not contain the `gemini-cli` package yet.

To fix this, we did two things:

1.  **Updated `flake.nix`:** We changed the `nixpkgs` input to point to `github:NixOS/nixpkgs/master`. The `master` branch of `nixpkgs` contains the latest packages, including `gemini-cli`.
2.  **Ran `nix flake update`:** We ran this command to update the `flake.lock` file to match the new `flake.nix` file. This command fetches the latest commit from the `master` branch of `nixpkgs` and records it in the `flake.lock` file.

By doing this, we are now using the latest version of `nixpkgs`, which includes the `gemini-cli` package. The next step is to run `nix-on-droid switch` again, which should now succeed.
